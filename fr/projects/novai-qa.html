<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Novai QA : Construction d’un système de questions-réponses sur romans sans spoilers – Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-985aa47af68dae11cd4d235c71fb941e.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-991b1886d3c685c7aa2b62b80640c7af.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Accueil</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../projects.html"> 
<span class="menu-text">Projets</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">À Propos</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../#"> 
<span class="menu-text">English</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#aperçu-du-projet" id="toc-aperçu-du-projet" class="nav-link active" data-scroll-target="#aperçu-du-projet">Aperçu du projet</a>
  <ul class="collapse">
  <li><a href="#le-défi" id="toc-le-défi" class="nav-link" data-scroll-target="#le-défi">Le défi</a></li>
  <li><a href="#ma-solution" id="toc-ma-solution" class="nav-link" data-scroll-target="#ma-solution">Ma solution</a></li>
  </ul></li>
  <li><a href="#architecture-technique" id="toc-architecture-technique" class="nav-link" data-scroll-target="#architecture-technique">Architecture technique</a>
  <ul class="collapse">
  <li><a href="#philosophie-de-conception-du-système" id="toc-philosophie-de-conception-du-système" class="nav-link" data-scroll-target="#philosophie-de-conception-du-système">Philosophie de conception du système</a></li>
  <li><a href="#plongée-profonde-dans-les-composants-principaux" id="toc-plongée-profonde-dans-les-composants-principaux" class="nav-link" data-scroll-target="#plongée-profonde-dans-les-composants-principaux">Plongée profonde dans les composants principaux</a></li>
  </ul></li>
  <li><a href="#défis-dimplémentation-et-solutions" id="toc-défis-dimplémentation-et-solutions" class="nav-link" data-scroll-target="#défis-dimplémentation-et-solutions">Défis d’implémentation et solutions</a>
  <ul class="collapse">
  <li><a href="#défi-1-gérer-les-romans-très-longs" id="toc-défi-1-gérer-les-romans-très-longs" class="nav-link" data-scroll-target="#défi-1-gérer-les-romans-très-longs">Défi 1 : Gérer les romans très longs</a></li>
  <li><a href="#défi-2-préservation-du-contexte-entre-les-chunks" id="toc-défi-2-préservation-du-contexte-entre-les-chunks" class="nav-link" data-scroll-target="#défi-2-préservation-du-contexte-entre-les-chunks">Défi 2 : Préservation du contexte entre les chunks</a></li>
  <li><a href="#défi-3-variations-des-noms-de-personnages" id="toc-défi-3-variations-des-noms-de-personnages" class="nav-link" data-scroll-target="#défi-3-variations-des-noms-de-personnages">Défi 3 : Variations des noms de personnages</a></li>
  <li><a href="#défi-4-précision-des-limites-de-spoilers" id="toc-défi-4-précision-des-limites-de-spoilers" class="nav-link" data-scroll-target="#défi-4-précision-des-limites-de-spoilers">Défi 4 : Précision des limites de spoilers</a></li>
  </ul></li>
  <li><a href="#analyse-de-performance" id="toc-analyse-de-performance" class="nav-link" data-scroll-target="#analyse-de-performance">Analyse de performance</a>
  <ul class="collapse">
  <li><a href="#métriques-et-benchmarks" id="toc-métriques-et-benchmarks" class="nav-link" data-scroll-target="#métriques-et-benchmarks">Métriques et benchmarks</a></li>
  <li><a href="#considérations-de-scalabilité" id="toc-considérations-de-scalabilité" class="nav-link" data-scroll-target="#considérations-de-scalabilité">Considérations de scalabilité</a></li>
  </ul></li>
  <li><a href="#conception-de-lexpérience-utilisateur" id="toc-conception-de-lexpérience-utilisateur" class="nav-link" data-scroll-target="#conception-de-lexpérience-utilisateur">Conception de l’expérience utilisateur</a>
  <ul class="collapse">
  <li><a href="#philosophie-dinterface" id="toc-philosophie-dinterface" class="nav-link" data-scroll-target="#philosophie-dinterface">Philosophie d’interface</a></li>
  <li><a href="#patterns-dinteraction" id="toc-patterns-dinteraction" class="nav-link" data-scroll-target="#patterns-dinteraction">Patterns d’interaction</a></li>
  </ul></li>
  <li><a href="#stack-technique-et-dépendances" id="toc-stack-technique-et-dépendances" class="nav-link" data-scroll-target="#stack-technique-et-dépendances">Stack technique et dépendances</a>
  <ul class="collapse">
  <li><a href="#technologies-principales" id="toc-technologies-principales" class="nav-link" data-scroll-target="#technologies-principales">Technologies principales</a></li>
  <li><a href="#exigences-matérielles" id="toc-exigences-matérielles" class="nav-link" data-scroll-target="#exigences-matérielles">Exigences matérielles</a></li>
  </ul></li>
  <li><a href="#rétrospective-de-développement" id="toc-rétrospective-de-développement" class="nav-link" data-scroll-target="#rétrospective-de-développement">Rétrospective de développement</a></li>
  <li><a href="#leçons-apprises-et-directions-futures" id="toc-leçons-apprises-et-directions-futures" class="nav-link" data-scroll-target="#leçons-apprises-et-directions-futures">Leçons apprises et directions futures</a>
  <ul class="collapse">
  <li><a href="#insights-clés" id="toc-insights-clés" class="nav-link" data-scroll-target="#insights-clés">Insights clés</a></li>
  <li><a href="#améliorations-futures" id="toc-améliorations-futures" class="nav-link" data-scroll-target="#améliorations-futures">Améliorations futures</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Novai QA : Construction d’un système de questions-réponses sur romans sans spoilers</h1>
<p class="subtitle lead">Une approche basée sur RAG pour l’analyse de littérature longue</p>
</div>



<div class="quarto-title-meta column-page-left">

    
  
    
  </div>
  


</header>


<section id="aperçu-du-projet" class="level2">
<h2 class="anchored" data-anchor-id="aperçu-du-projet">Aperçu du projet</h2>
<p><strong>Novai QA</strong> représente une approche novatrice pour gérer l’un des problèmes les plus difficiles dans la discussion littéraire : la gestion des spoilers. Ce système de génération augmentée par récupération (RAG) permet aux lecteurs de poser des questions sur des romans web tout en maintenant des limites strictes sans spoilers basées sur leur progression de lecture actuelle.</p>
<section id="le-défi" class="level3">
<h3 class="anchored" data-anchor-id="le-défi">Le défi</h3>
<p>Les romans web de longue durée, particulièrement ceux des plateformes comme novelfull.com, s’étendent souvent sur des milliers de chapitres avec des relations de personnages complexes et des développements d’intrigue complexes. Les lecteurs veulent fréquemment :</p>
<ul>
<li>Clarifier les relations entre personnages sans gâcher les développements futurs</li>
<li>Comprendre des éléments complexes de construction du monde</li>
<li>Obtenir des rappels sur les événements passés sans relire des sections entières</li>
<li>Discuter des points d’intrigue avec confiance en matière de sécurité des spoilers</li>
</ul>
<p>Les approches traditionnelles échouent parce qu’elles soit : 1. Ne fournissent aucune protection contre les spoilers 2. Nécessitent une curation manuelle du contenu 3. Ne peuvent pas gérer l’échelle de très longs romans 4. Manquent de compréhension contextuelle nécessaire pour des questions nuancées</p>
</section>
<section id="ma-solution" class="level3">
<h3 class="anchored" data-anchor-id="ma-solution">Ma solution</h3>
<p>J’ai développé un pipeline RAG sophistiqué qui combine :</p>
<ul>
<li><strong>Web scraping intelligent</strong> pour l’acquisition automatisée de contenu</li>
<li><strong>Systèmes de récupération hybrides</strong> mélangeant recherche sémantique et par mots-clés</li>
<li><strong>Filtrage de spoilers basé sur les chapitres</strong> pour la conscience de progression de l’utilisateur</li>
<li><strong>Intégration LLM locale</strong> pour la confidentialité et le contrôle</li>
<li><strong>Chunking conscient du contexte</strong> pour une récupération d’information optimale</li>
</ul>
</section>
</section>
<section id="architecture-technique" class="level2">
<h2 class="anchored" data-anchor-id="architecture-technique">Architecture technique</h2>
<section id="philosophie-de-conception-du-système" class="level3">
<h3 class="anchored" data-anchor-id="philosophie-de-conception-du-système">Philosophie de conception du système</h3>
<p>L’architecture suit une conception de pipeline modulaire, où chaque composant peut être optimisé et remplacé indépendamment :</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/NovaiQA-workflow.png" class="img-fluid figure-img"></p>
<figcaption>Workflow Novai QA</figcaption>
</figure>
</div>
</section>
<section id="plongée-profonde-dans-les-composants-principaux" class="level3">
<h3 class="anchored" data-anchor-id="plongée-profonde-dans-les-composants-principaux">Plongée profonde dans les composants principaux</h3>
<section id="module-de-web-scraping-scraper.py" class="level4">
<h4 class="anchored" data-anchor-id="module-de-web-scraping-scraper.py">1. Module de web scraping (<code>scraper.py</code>)</h4>
<p>Le système de scraping gère la tâche complexe d’extraire le contenu de romans depuis novelfull.com tout en gérant :</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">async</span> <span class="kw">def</span> refresh_database():</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Découverte interactive de romans et extraction de contenu par lots</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sélection de roman guidée par l'utilisateur</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    keyword <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Please enter a keyword to search for novels: "</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Scraping conscient de Cloudflare avec des en-têtes factices</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    headers <span class="op">=</span> header.generate()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    connector <span class="op">=</span> aiohttp.TCPConnector(limit<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extraction de chapitres concurrente</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    tasks <span class="op">=</span> [get_page_content(session, url) <span class="cf">for</span> url <span class="kw">in</span> chapter_urls]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    chapter_contents <span class="op">=</span> <span class="cf">await</span> asyncio.gather(<span class="op">*</span>tasks)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Fonctionnalités clés :</strong><br>
- <strong>Gestion de la protection Cloudflare</strong> : Génération d’en-têtes dynamiques et pooling de connexions<br>
- <strong>Traitement concurrent</strong> : Opérations async pour des téléchargements par lots efficaces<br>
- <strong>Validation de contenu</strong> : Détection automatique et retraitement des téléchargements échoués<br>
- <strong>Intégration base de données</strong> : Insertion directe avec résolution de conflits</p>
</section>
<section id="système-de-chunking-intelligent-chunker.py" class="level4">
<h4 class="anchored" data-anchor-id="système-de-chunking-intelligent-chunker.py">2. Système de chunking intelligent (<code>chunker.py</code>)</h4>
<p>L’algorithme de chunking représente l’un des aspects les plus sophistiqués du système :</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> chunk_text(text, max_chunk_size<span class="op">=</span><span class="dv">512</span>, overlap<span class="op">=</span><span class="dv">200</span>, tokenizer<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Chunking adaptatif avec préservation du contexte</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    paragraphs <span class="op">=</span> segment_text(text, max_chunk_size, overlap, tokenizer)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Gestion sophistiquée du chevauchement</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> current_chunk_size <span class="op">&lt;=</span> size <span class="op">+</span> overlap:</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> j <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> current_chunk_size <span class="op">&lt;=</span> max_chunk_size <span class="op">-</span> paragraphs[j][<span class="dv">1</span>]:</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            current_chunk.insert(<span class="dv">0</span>, paragraphs[j][<span class="dv">0</span>])</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            current_chunk_size <span class="op">+=</span> paragraphs[j][<span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Conception de l’algorithme :</strong><br>
- <strong>Fallback multi-niveau</strong> : Segmentation Paragraphe → Phrase → Sous-phrase<br>
- <strong>Chevauchement conscient du contexte</strong> : Détection intelligente des limites pour préserver le sens<br>
- <strong>Dimensionnement précis des tokens</strong> : Utilise le tokenizer du modèle réel pour un calcul de taille précis<br>
- <strong>Traitement adaptatif</strong> : Gère automatiquement les structures de contenu variées</p>
</section>
<section id="système-de-récupération-hybride-retriever.py" class="level4">
<h4 class="anchored" data-anchor-id="système-de-récupération-hybride-retriever.py">3. Système de récupération hybride (<code>retriever.py</code>)</h4>
<p>Le système de récupération combine deux approches complémentaires :</p>
<p><strong>Recherche sémantique (ChromaDB) :</strong></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> retrieve_context_chroma(query, novel_name, model, spoiler_threshold<span class="op">=</span><span class="va">None</span>, k<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    query_prompt <span class="op">=</span> <span class="st">"Represent this sentence for searching relevant passages: "</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    query_vector <span class="op">=</span> model.encode(query_prompt <span class="op">+</span> query)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    query_vector <span class="op">=</span> query_vector <span class="op">/</span> np.linalg.norm(query_vector)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> spoiler_threshold:</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        results <span class="op">=</span> collection.query(</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            query_embeddings<span class="op">=</span>[query_vector.tolist()],</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            where<span class="op">=</span>{<span class="st">"chapter_id"</span>: {<span class="st">"$lte"</span>: spoiler_threshold}}</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Recherche par mots-clés (BM25) :</strong></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> retrieve_context_bm25(query, novel_name, spoiler_threshold<span class="op">=</span><span class="va">None</span>, k<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Pipeline de prétraitement avancé</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    query_tokens <span class="op">=</span> preprocess(query)  <span class="co"># Lemmatisation + étiquetage POS</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    bm25 <span class="op">=</span> BM25Okapi(tokenized_docs)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> bm25.get_scores(query_tokens)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Stratégie de fusion :</strong> Le système combine les résultats des deux méthodes, exploitant les forces de chacune :<br>
- La recherche sémantique excelle dans les requêtes conceptuelles et les synonymes<br>
- BM25 capture les correspondances exactes de noms et la terminologie spécifique<br>
- Les résultats combinés fournissent une couverture complète</p>
</section>
<section id="filtrage-conscient-des-spoilers" class="level4">
<h4 class="anchored" data-anchor-id="filtrage-conscient-des-spoilers">4. Filtrage conscient des spoilers</h4>
<p>Le mécanisme de protection contre les spoilers fonctionne au niveau de la requête de base de données pour l’efficacité :</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Filtrage basé sur les chapitres dans PostgreSQL</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>cursor.execute(<span class="st">"""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="st">    SELECT chunks.id, chunks.chunk_content </span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="st">    FROM chunks </span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="st">    JOIN chapters ON chunks.chapter_id = chapters.id </span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="st">    WHERE chapters.novel_id = </span><span class="sc">%s</span><span class="st"> AND chapters.chapter_number &lt;= </span><span class="sc">%s</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span>, (novel_id, spoiler_threshold))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Cette approche assure :<br>
- <strong>Efficacité au niveau de la base de données</strong> : Le filtrage se produit pendant la récupération, pas en post-traitement<br>
- <strong>Contrôle précis</strong> : Limites de spoilers granulaires par chapitre<br>
- <strong>Agence utilisateur</strong> : Protection optionnelle contre les spoilers basée sur la préférence utilisateur</p>
</section>
<section id="génération-de-réponses-generator.py" class="level4">
<h4 class="anchored" data-anchor-id="génération-de-réponses-generator.py">5. Génération de réponses (<code>generator.py</code>)</h4>
<p>Le système de génération utilise des prompts soigneusement conçus pour assurer des réponses fondées :</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>system_prompt <span class="op">=</span> <span class="st">"""You are a RAG system designed to answer questions about novels </span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="st">using only the retrieved excerpts from the book. Your responses must be grounded </span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="st">in the supplied content, without guessing or adding external information."""</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Fonctionnalités clés :</strong><br>
- <strong>Fondation stricte</strong> : Réponses limitées au contenu récupéré seulement<br>
- <strong>Langage naturel</strong> : Aucune exposition des mécaniques système aux utilisateurs<br>
- <strong>Gestion des chaînes de pensée</strong> : Traitement spécial pour les modèles basés sur le raisonnement<br>
- <strong>Incertitude gracieuse</strong> : Admission honnête quand l’information n’est pas disponible</p>
</section>
</section>
</section>
<section id="défis-dimplémentation-et-solutions" class="level2">
<h2 class="anchored" data-anchor-id="défis-dimplémentation-et-solutions">Défis d’implémentation et solutions</h2>
<section id="défi-1-gérer-les-romans-très-longs" class="level3">
<h3 class="anchored" data-anchor-id="défi-1-gérer-les-romans-très-longs">Défi 1 : Gérer les romans très longs</h3>
<p><strong>Problème</strong> : Les romans avec plus de 1000 chapitres génèrent des dizaines de milliers de chunks, rendant la récupération coûteuse en calcul.</p>
<p><strong>Solution</strong> :<br>
- <strong>Filtrage hiérarchique</strong> : Filtrage au niveau base de données des romans et chapitres avant la recherche sémantique<br>
- <strong>Traitement par lots</strong> : Génération d’embeddings optimisée avec accélération CUDA<br>
- <strong>Pooling de connexions</strong> : Gestion efficace des ressources de base de données</p>
</section>
<section id="défi-2-préservation-du-contexte-entre-les-chunks" class="level3">
<h3 class="anchored" data-anchor-id="défi-2-préservation-du-contexte-entre-les-chunks">Défi 2 : Préservation du contexte entre les chunks</h3>
<p><strong>Problème</strong> : L’information critique s’étend souvent au-delà des limites de paragraphes, conduisant à un contexte fragmenté.</p>
<p><strong>Solution</strong> :</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Chevauchement intelligent avec conscience du contexte</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> i <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> current_chunk_size <span class="op">&lt;=</span> size <span class="op">+</span> overlap:</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> j <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> current_chunk_size <span class="op">&lt;=</span> max_chunk_size <span class="op">-</span> paragraphs[j][<span class="dv">1</span>]:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        current_chunk.insert(<span class="dv">0</span>, paragraphs[j][<span class="dv">0</span>])  <span class="co"># Ajouter le contexte précédent</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Cela assure que chaque chunk contient suffisamment de contexte pour une compréhension autonome.</p>
</section>
<section id="défi-3-variations-des-noms-de-personnages" class="level3">
<h3 class="anchored" data-anchor-id="défi-3-variations-des-noms-de-personnages">Défi 3 : Variations des noms de personnages</h3>
<p><strong>Problème</strong> : Les romans web utilisent souvent plusieurs noms/titres pour les personnages, rendant la récupération incohérente.</p>
<p><strong>Solution</strong> : Système de récupération hybride où :<br>
- BM25 capture les correspondances exactes de noms et variations<br>
- La recherche sémantique capture les références conceptuelles<br>
- Les résultats combinés assurent une couverture complète des personnages</p>
</section>
<section id="défi-4-précision-des-limites-de-spoilers" class="level3">
<h3 class="anchored" data-anchor-id="défi-4-précision-des-limites-de-spoilers">Défi 4 : Précision des limites de spoilers</h3>
<p><strong>Problème</strong> : Déterminer les limites exactes de spoilers tout en maintenant l’efficacité de récupération.</p>
<p><strong>Solution</strong> : Granularité au niveau chapitre avec filtrage au niveau base de données :<br>
- <strong>Contrôle utilisateur</strong> : Spécification explicite de chapitre<br>
- <strong>Approche conservatrice</strong> : En cas d’incertitude, prioriser la sécurité des spoilers<br>
- <strong>Implémentation efficace</strong> : Optimisation des requêtes PostgreSQL</p>
</section>
</section>
<section id="analyse-de-performance" class="level2">
<h2 class="anchored" data-anchor-id="analyse-de-performance">Analyse de performance</h2>
<section id="métriques-et-benchmarks" class="level3">
<h3 class="anchored" data-anchor-id="métriques-et-benchmarks">Métriques et benchmarks</h3>
<p><strong>Performance de chunking :</strong><br>
- Roman moyen (500 chapitres) : ~15-20 minutes de temps de traitement<br>
- Génération de chunks : ~5,000-8,000 chunks par roman<br>
- Usage mémoire : ~2-4GB pendant le pic de traitement</p>
<p><strong>Vitesse de récupération :</strong><br>
- Traitement de requête : &lt;2 secondes en moyenne<br>
- Recherche hybride : 10 chunks de chaque méthode (20 total)<br>
- Requêtes base de données : &lt;100ms avec indexation appropriée</p>
<p><strong>Qualité de réponse :</strong><br>
- Précision fondée : Haute adhérence au matériel source<br>
- Cohérence contextuelle : Performance forte due à la stratégie de chevauchement<br>
- Sécurité spoilers : 100% quand le seuil est correctement défini</p>
</section>
<section id="considérations-de-scalabilité" class="level3">
<h3 class="anchored" data-anchor-id="considérations-de-scalabilité">Considérations de scalabilité</h3>
<p><strong>Limites actuelles :</strong> - Focus sur un seul roman (par conception)<br>
- Exigences mémoire GPU pour les embeddings<br>
- Mise à l’échelle du stockage PostgreSQL avec le nombre de romans</p>
<p><strong>Opportunités d’optimisation :</strong><br>
- Cache des chunks fréquemment accédés<br>
- Embeddings pré-calculés pour les requêtes communes<br>
- Texte prétraité (lemmatisé + étiquetage POS) pour les requêtes communes<br>
- Traitement distribué pour plusieurs romans</p>
</section>
</section>
<section id="conception-de-lexpérience-utilisateur" class="level2">
<h2 class="anchored" data-anchor-id="conception-de-lexpérience-utilisateur">Conception de l’expérience utilisateur</h2>
<section id="philosophie-dinterface" class="level3">
<h3 class="anchored" data-anchor-id="philosophie-dinterface">Philosophie d’interface</h3>
<p>L’interface Gradio priorise la simplicité tout en fournissant les contrôles essentiels :</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> gr.Blocks(title<span class="op">=</span><span class="st">"Novel Assistant Chatbot"</span>, theme<span class="op">=</span>gr.themes.Soft()) <span class="im">as</span> demo:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    novel_name <span class="op">=</span> gr.Textbox(label<span class="op">=</span><span class="st">"Novel Name"</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    spoiler_threshold <span class="op">=</span> gr.Number(label<span class="op">=</span><span class="st">"Current Chapter (optional)"</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    chatbot <span class="op">=</span> gr.Chatbot(height<span class="op">=</span><span class="dv">500</span>, bubble_full_width<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="../images/novaiqa-interface.png" class="img-fluid" alt="Interface Novai QA"> <em>Figure : Interface Novai QA au lancement, montrant la conception minimaliste et l’entrée de contrôle des spoilers.</em></p>
<p><strong>Principes de conception :</strong><br>
- <strong>Charge cognitive minimale</strong> : Contrôles essentiels uniquement<br>
- <strong>Contrôle de spoilers clair</strong> : Mécanisme d’entrée de chapitre évident<br>
- <strong>Flux conversationnel</strong> : Interface de chat naturelle<br>
- <strong>Feedback immédiat</strong> : Génération de réponse en temps réel</p>
</section>
<section id="patterns-dinteraction" class="level3">
<h3 class="anchored" data-anchor-id="patterns-dinteraction">Patterns d’interaction</h3>
<p><strong>Flux utilisateur typique :</strong><br>
1. <strong>Sélection de roman</strong> : Entrer le nom du roman (correspondance exacte requise)<br>
2. <strong>Réglage de progression</strong> : Spécifier le chapitre actuel (optionnel mais recommandé)<br>
3. <strong>Requête naturelle</strong> : Poser des questions en langage conversationnel<br>
4. <strong>Exploration itérative</strong> : Suivre avec des questions liées</p>
<p><strong>Exemples d’interactions :</strong></p>
<pre><code>Utilisateur : "Qui est le personnage principal dans Supreme Magus ?"
Système : "Basé sur le contenu de l'histoire, le personnage principal est Lith..."

Utilisateur : "Quelles sont ses capacités ?"
Système : "Lith démontre plusieurs capacités clés incluant..."</code></pre>
</section>
</section>
<section id="stack-technique-et-dépendances" class="level2">
<h2 class="anchored" data-anchor-id="stack-technique-et-dépendances">Stack technique et dépendances</h2>
<section id="technologies-principales" class="level3">
<h3 class="anchored" data-anchor-id="technologies-principales">Technologies principales</h3>
<p><strong>Framework backend :</strong><br>
- <strong>Python 3.12+</strong> : Langage de développement principal<br>
- <strong>PostgreSQL</strong> : Stockage de données primaire<br>
- <strong>ChromaDB</strong> : Recherche de similarité vectorielle<br>
- <strong>Ollama</strong> : Service LLM local</p>
<p><strong>Machine Learning :</strong><br>
- <strong>SentenceTransformers</strong> : Génération d’embeddings<br>
- <strong>NLTK</strong> : Pipeline de prétraitement de texte<br>
- <strong>rank-bm25</strong> : Implémentation de recherche par mots-clés</p>
<p><strong>Technologies web :</strong><br>
- <strong>Gradio</strong> : Interface interactive<br>
- <strong>aiohttp</strong> : Web scraping asynchrone<br>
- <strong>BeautifulSoup</strong> : Parsing HTML</p>
</section>
<section id="exigences-matérielles" class="level3">
<h3 class="anchored" data-anchor-id="exigences-matérielles">Exigences matérielles</h3>
<p><strong>Spécifications minimales :</strong><br>
- 16GB RAM (pour les modèles d’embeddings)<br>
- GPU compatible CUDA (recommandé)<br>
- 10GB+ stockage (varie selon le nombre de romans)<br>
- Internet stable (pour le scraping initial)</p>
<p><strong>Configuration optimale :</strong><br>
- 32GB+ RAM<br>
- RTX 3080/4080 ou équivalent<br>
- Stockage SSD pour la performance de base de données<br>
- Connexion internet haut débit</p>
</section>
</section>
<section id="rétrospective-de-développement" class="level2">
<h2 class="anchored" data-anchor-id="rétrospective-de-développement">Rétrospective de développement</h2>
<ul>
<li><strong>Complexité de chunking sous-estimée</strong> : Initialement assumé être une tâche simple, l’implémentation du chunking basé sur le chevauchement s’est révélée significativement plus complexe. Développement d’une solution personnalisée après avoir fait face à de multiples cas limites dans la préservation du contexte.<br>
</li>
<li><strong>Exploration de vector store</strong> : Commencé avec FAISS mais abandonné en raison du manque de filtrage natif des métadonnées. Considéré Milvus, mais il n’était pas disponible sur Windows au moment du développement.<br>
</li>
<li><strong>Réalisation de récupération hybride</strong> : BM25 a été introduit pour compléter la recherche sémantique mais a donné de mauvais résultats sans lemmatisation. Une lemmatisation efficace nécessitait l’étiquetage POS, ce qui ajoutait une surcharge de traitement.<br>
</li>
<li><strong>Impact matériel sur les embeddings</strong> : L’encodage de ~1000 chapitres avec un GPU a pris ~40 minutes ; le temps CPU estimé dépassait 8 heures. A souligné l’écart critique de performance entre CPU et matériel compatible CUDA.<br>
</li>
<li><strong>Migration de base de données</strong> : Transition de SQLite vers PostgreSQL pour un filtrage robuste et des requêtes relationnelles. Cependant, ChromaDB a continué à utiliser SQLite3 localement comme backend.<br>
</li>
<li><strong>Logging opérationnel</strong> : Introduction du logging au niveau application pour surveiller plus systématiquement les processus de scraping, chunking et récupération.</li>
</ul>
</section>
<section id="leçons-apprises-et-directions-futures" class="level2">
<h2 class="anchored" data-anchor-id="leçons-apprises-et-directions-futures">Leçons apprises et directions futures</h2>
<section id="insights-clés" class="level3">
<h3 class="anchored" data-anchor-id="insights-clés">Insights clés</h3>
<ol type="1">
<li><strong>La stratégie de chunking compte</strong> : La qualité de segmentation de texte impacte directement la qualité de récupération</li>
<li><strong>Les approches hybrides gagnent</strong> : Combiner recherche sémantique et par mots-clés fournit une couverture supérieure</li>
<li><strong>L’agence utilisateur est critique</strong> : Le contrôle des spoilers doit être piloté par l’utilisateur, pas assumé par le système</li>
<li><strong>Les avantages du traitement local</strong> : Les avantages de confidentialité et contrôle surpassent la commodité des API cloud</li>
</ol>
</section>
<section id="améliorations-futures" class="level3">
<h3 class="anchored" data-anchor-id="améliorations-futures">Améliorations futures</h3>
<p><strong>Améliorations techniques :</strong><br>
- <strong>Reranking avancé</strong> : Scoring de pertinence basé sur LLM pour le contenu récupéré<br>
- <strong>Support multi-romans</strong> : Gestion concurrente de multiples sources de romans<br>
- <strong>Conversation multi-tour</strong> : Traitement conscient du contexte pour les requêtes de suivi<br>
- <strong>Mémoire de conversation</strong> : Contexte persistant à travers les sessions de chat<br>
- <strong>Système de mise à jour automatique</strong> : Synchronisation périodique du contenu avec les bases de données de romans</p>
<p><strong>Expérience utilisateur :</strong><br>
- <strong>Progressive Web App</strong> : Interface optimisée mobile<br>
- <strong>Intégration progression de lecture</strong> : Suivi automatique des chapitres<br>
- <strong>Fonctionnalités sociales</strong> : Discussions partagées avec conscience des spoilers<br>
- <strong>Personnalisation</strong> : Apprentissage et adaptation des préférences utilisateur</p>
<p><strong>Scalabilité et performance :</strong><br>
- <strong>Couche de cache</strong> : Intégration Redis pour les requêtes fréquentes<br>
- <strong>Traitement distribué</strong> : Génération d’embeddings multi-GPU<br>
- <strong>Développement API</strong> : Endpoints REST pour intégrations tierces<br>
- <strong>Containerisation</strong> : Déploiement Docker pour mise à l’échelle facile</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Le projet Novai QA démontre l’application pratique de techniques NLP modernes pour résoudre des problèmes du monde réel dans la consommation de littérature numérique. En combinant web scraping, traitement de texte avancé, systèmes de récupération hybrides et génération LLM locale, le système fournit une solution unique au défi de gestion des spoilers.</p>
<p>Le projet présente plusieurs compétences techniques clés :<br>
- <strong>Développement full-stack</strong> : De la conception de base de données à l’interface web<br>
- <strong>Ingénierie de pipeline NLP</strong> : Workflows de traitement de texte bout en bout<br>
- <strong>Architecture de système RAG</strong> : Récupération et génération d’information modernes<br>
- <strong>Programmation asynchrone</strong> : Traitement concurrent efficace<br>
- <strong>Optimisation de base de données</strong> : Performance de requêtes et modélisation de données</p>
<p>Plus important encore, il répond à un besoin utilisateur genuine avec une approche réfléchie et techniquement solide qui priorise le contrôle utilisateur et la sécurité du contenu.</p>
<hr>
<p><em>Ce projet fait partie de mon portfolio démontrant l’expertise en NLP, systèmes RAG et développement full-stack. Le code complet et la documentation sont disponibles sur <a href="https://github.com/Overowser/Novai-QA">GitHub</a>.</em></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<script src="../language-toggle.js"></script>




</body></html>